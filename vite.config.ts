import { defineConfig, IndexHtmlTransformContext, Plugin } from 'vite';
import { viteSingleFile } from 'vite-plugin-singlefile';
import { ViteMinifyPlugin } from 'vite-plugin-minify';
import { OutputChunk, OutputAsset } from 'rollup'
import htmlMinify from 'html-minifier-terser'
import CleanCSS from 'clean-css'
import { Input, InputType, InputAction, Packer } from 'roadroller'

export default defineConfig({
    esbuild: {
        legalComments: 'none'
    },
    plugins: [
        // roadRollerPlugin(),
        ViteMinifyPlugin(),
        viteSingleFile(),
    ]
});

function roadRollerPlugin(): Plugin {
    return {
        name: 'vite:roadroller',
        transformIndexHtml: {
            enforce: 'post',
            handler: async (html: string, ctx?: IndexHtmlTransformContext): Promise<string> => {
				if (!ctx || !ctx.bundle) {
					return html;
				}

				const options = {
					includeAutoGeneratedTags: true,
					removeAttributeQuotes: true,
					removeComments: true,
					removeRedundantAttributes: true,
					removeScriptTypeAttributes: true,
					removeStyleLinkTypeAttributes: true,
					sortClassName: true,
					useShortDoctype: true,
					collapseWhitespace: true,
					collapseInlineTagWhitespace: true,
					removeEmptyAttributes: true,
					removeOptionalTags: true,
					sortAttributes: true,
				};

				const bundleOutputs = Object.values(ctx.bundle);
				const javascript = bundleOutputs.find((output) => output.fileName.endsWith('.js')) as OutputChunk;
				const css = bundleOutputs.find((output) => output.fileName.endsWith('.css')) as OutputAsset;
				const otherBundleOutputs = bundleOutputs.filter((output) => output !== javascript && output !== css);
				if (otherBundleOutputs.length > 0) {
					otherBundleOutputs.forEach((output) => console.warn(`WARN Asset not inlined: ${output.fileName}`));
				}

				const cssInHtml = css ? embedCss(html, css) : html;
				const minifiedHtml = await htmlMinify.minify(cssInHtml, options);
				return embedJs(minifiedHtml, javascript);
            }
        }
    }
}

async function embedJs(html: string, chunk: OutputChunk): Promise<string> {
	const scriptTagRemoved = html.replace(new RegExp(`<script[^>]*?src=[\./]*${chunk.fileName}[^>]*?></script>`), '');
	const htmlInJs = `document.write('${scriptTagRemoved}');` + chunk.code.trim();

	const inputs: Input[] = [
		{
			data: htmlInJs,
			type: 'js' as InputType,
			action: 'eval' as InputAction,
		},
	];
	const options = {};
	const packer = new Packer(inputs, options);
	await packer.optimize(2);
	const { firstLine, secondLine } = packer.makeDecoder();
	return `<script>\n${firstLine}\n${secondLine}\n</script>`;
}

function embedCss(html: string, asset: OutputAsset): string {
	const reCSS = new RegExp(`<link rel="stylesheet"[^>]*?href="[\./]*${asset.fileName}"[^>]*?>`);
	const code = `<style>${new CleanCSS({ level: 2 }).minify(asset.source as string).styles}</style>`;
	return html.replace(reCSS, code);
}